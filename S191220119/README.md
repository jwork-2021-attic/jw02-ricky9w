# W02
191220119 王毓琦

## 文件结构

```
.
├── S191220119		//作业目录
│   ├── task1
│   ├── task2
│   │   ├── asset	//资源目录
│   │   └── src		//源码目录
│   ├── task3
│   │   ├── asset
│   │   └── src
│   └── utils			//代码公共依赖
├── bin						//生成的二进制文件
│   └── example
├── example				//示例代码
└── utils					//公共依赖项
```

## 类图的生成





## 任务一

example中的类图如下:



main方法执行过程中对象时序图如下:



阅读示例代码后发现的优点和可改进之处如下:

优点:

+ `Geezer` 类使用了 Singleton 设计思想, 保证全局只能出现一个 `Geezer` 对象, 这也符合实际逻辑

+ `Sorter` 类是一个抽象类, 对外提供了三个接口, `BubbleSorter` 类则是冒泡排序算法的具体实现. 这种设计方法使得接口统一, 维护方便, 层次清晰, 功能逻辑与具体实现分开. `Linable` 同样是一个抽象类, `Gourd` 是它的一种具体实现
+ `Linable` 和 `Position` 共同组成了类似“容器”的效果, 对数组中的元素的排序和移动加了一层抽象, 更加通用化

改进:

+ 可以将类中变量的声明放在方法定义之前, 提高代码可读性

## 任务二
任务二的类图如下:



大致思路:

使用 `Matrix` 类代替示例代码中的 `Line` 类, 该类中数据存储在一个一维数组中, 类中同时记录着矩阵的行数和列数信息, 根据该信息决定矩阵的打印输出.

任务二中的排成一行操作相当于在一个 1x256 的矩阵中进行排序, 任务三则相当于在一个 16x16 的矩阵中排序, 因此需要修改的代码很少.



可视化结果展示:



## 任务三
任务三的类图如下:



相比任务二的修改:

前面提到任务二和任务三的区别只是矩阵的参数不同, 因此任务三相比任务二只是在创建矩阵时



可视化结果展示:


